const quoridorCtrl = {};
const chalk = require("chalk");
const { server } = require("websocket");

let {paintboard, load_matrix} = require("../utils/paint");
let {find_paws, find_nexts, select_move, find_right_left} = require("../utils/matrix");

quoridorCtrl.connectError = (error) => {
  console.log("Connect Error: " + error.toString());
};

quoridorCtrl.connectOk = (connection) => {
  console.log("WebSocket Client Connected");

  connection.on("error", connectOK_error);

  connection.on("close", connectOK_close);

  connection.on("message", (message) => {
  
    if (message.type === "utf8") {
      let server_message = JSON.parse(message.utf8Data);
  
      if (server_message.event == "list_users") {
          list_users(server_message);
      }
  
      if (server_message.event == "challenge") {
          challenge(server_message, connection);
      } 
  
      if (server_message.event == "your_turn") {
          your_turn(server_message, connection);
  
      }
    }
    else {
      console.log("No valid message type");
    }
  });
};

const connectOK_error = (error) => {
  console.log("Connection Error: " + error.toString());
};

const connectOK_close = () => {
  console.log("echo-protocol Connection Closed");
};

const list_users = function (server_message) {

    let console_message = "Users connected: ";
    console.log(chalk.blue("Connected users: ") + server_message.data.users);

}

const challenge = function (server_message, connection) {
   
    const challenge_answer = JSON.stringify({
        action: "accept_challenge",
        data: {
          challenge_id: server_message.data.challenge_id,
        },
      });

        
      try {
        const answer = connection.sendUTF(challenge_answer);
        console.log(
          chalk.yellowBright("Challenge accepted to: ") +
            server_message.data.opponent
        );
      } catch (error) {
        console.log(error);
      }
 

}

const your_turn = function (server_message, connection) {
    
    let your_turn_answer = "";

    if (server_message.data.side === 'N') {
        
        
        const board = server_message.data.board;
        const move = select_move (board, 'N') 

        console.log ('movement N')
        console.log (move)
        if (move) {
          your_turn_answer = JSON.stringify(
            {
                 
                   "action": "move",
                   "data": {
                      "game_id": server_message.data.game_id,
                      "turn_token": server_message.data.turn_token,
                      "from_row": (move.row_orig/2),
                      "from_col": (move.col_orig/2),
                      "to_row": (move.row_dest/2),
                      "to_col": (move.col_dest/2)

                     
                  
                   },
                   hello: "Hi dear bot, I only know how to move paws N",}
         );

        }

       


   
   

    }
    else {
     /* your_turn_answer = JSON.stringify(
           
        {
            action: "wall",
            data: {
              game_id: server_message.data.game_id,
              turn_token: server_message.data.turn_token,
              row: 0,
              col: 0,
              orientation: "h",
            },
            hello: "Hi dear bot, I only know how to build a horizontal wall",
          }
        );
*/


const board = server_message.data.board;
const move = select_move (board, 'S') 
console.log ('movement S')
console.log (move)
  if (move) {
    your_turn_answer = JSON.stringify(
      {
           
             "action": "move",
             "data": {
                "game_id": server_message.data.game_id,
                "turn_token": server_message.data.turn_token,
                "from_row": (move.row_orig/2),
                "from_col": (move.col_orig/2),
                "to_row": (move.row_dest/2),
                "to_col": (move.col_dest/2)
             },
             hello: "Hi dear bot, I only know how to move paws S",}
   );
  }
 
  }
  if (your_turn_answer.length > 0 ) {
    const answer = connection.sendUTF(your_turn_answer);
    console.log(
        chalk.cyan(
          "My movement: " +
            server_message.data.player_1 +
            " " +
            server_message.data.player_2 + "-" + your_turn_answer

        )
      );

  }
  else {
    console.log ('No next move')
  }



   
 }

  const matrix = [
    [
      'N', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'N'
    ],
    [
      ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '-'
    ],
    [
      ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '
    ],
    [
      ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '
    ],
    [
      ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '
    ],
    [
      ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '
    ],
    [
      ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '
    ],
    [
      ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '
    ],
    [
      ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '
    ],
    [
      ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '
    ],
    [
      ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '
    ],
    [
      '-', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '
    ],
    [
      ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '
    ],
    [
      ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' '
    ],
    
    [
      ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'N', ' ', ' '
    ],
    [
      ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '-', '*', '-'
    ],
    [
      ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', 'S', ' ', 'S', ' ', 'S', ' ', ' '
    ]
  ]


  //const paws = find_paws (matrix);

  //const paws_nexts = find_nexts (paws, matrix);

  //const move = select_move (paws, matrix, 'N')  

module.exports = quoridorCtrl;
